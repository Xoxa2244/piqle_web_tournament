// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String?
  role      UserRole @default(TD)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tournaments          Tournament[]
  assistantAssignments AssistantAssignment[]
  auditLogs           AuditLog[]

  @@map("users")
}

model Tournament {
  id                   String   @id @default(uuid())
  userId               String
  title                String
  description          String?
  rulesUrl             String?
  venueName            String?
  venueAddress         String?
  startDate            DateTime
  endDate              DateTime
  entryFee             Decimal? @db.Decimal(10, 2)
  isPublicBoardEnabled Boolean  @default(false)
  publicSlug           String?  @unique
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  // Relations
  user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  divisions   Division[]
  prizes      Prize[]
  rrGroups    RoundRobinGroup[]
  importJobs  ImportJob[]
  auditLogs   AuditLog[]
  players     Player[]

  @@map("tournaments")
}

model Prize {
  id           String   @id @default(uuid())
  tournamentId String
  divisionId   String?
  place        Int
  label        String
  amount       Decimal? @db.Decimal(10, 2)
  kind         PrizeKind @default(CASH)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  division   Division? @relation(fields: [divisionId], references: [id], onDelete: Cascade)

  @@map("prizes")
}

model Division {
  id           String      @id @default(uuid())
  tournamentId String
  name         String
  teamKind     TeamKind
  pairingMode  PairingMode
  poolCount    Int         @default(1)  // Number of pools (1 = no pools)
  maxTeams     Int?
  stage        DivisionStage @default(RR_IN_PROGRESS)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  // Relations
  tournament         Tournament           @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  constraints        DivisionConstraints?
  assistantAssignments AssistantAssignment[]
  pools              Pool[]
  teams              Team[]
  rrBindings         DivisionRRBinding[]
  matches            Match[]
  standings          Standing[]
  prizes             Prize[]

  @@map("divisions")
}

model DivisionConstraints {
  id         String   @id @default(uuid())
  divisionId String   @unique
  minDupr    Decimal? @db.Decimal(4, 2)
  maxDupr    Decimal? @db.Decimal(4, 2)
  minAge     Int?
  maxAge     Int?
  genders    GenderConstraint @default(ANY)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  division Division @relation(fields: [divisionId], references: [id], onDelete: Cascade)

  @@map("division_constraints")
}

model AssistantAssignment {
  id         String   @id @default(uuid())
  userId     String
  divisionId String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  division Division @relation(fields: [divisionId], references: [id], onDelete: Cascade)

  @@unique([userId, divisionId])
  @@map("assistant_assignments")
}

model Pool {
  id         String   @id @default(uuid())
  divisionId String
  name       String
  order      Int
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  division Division @relation(fields: [divisionId], references: [id], onDelete: Cascade)
  teams    Team[]
  matches  Match[]
  standings Standing[]

  @@map("pools")
}

model Team {
  id         String   @id @default(uuid())
  divisionId String
  poolId     String?
  name       String
  seed       Int?
  note       String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  division     Division     @relation(fields: [divisionId], references: [id], onDelete: Cascade)
  pool         Pool?        @relation(fields: [poolId], references: [id], onDelete: SetNull)
  teamPlayers  TeamPlayer[]
  matchesAsA   Match[]      @relation("TeamA")
  matchesAsB   Match[]      @relation("TeamB")
  standings    Standing[]

  @@map("teams")
}

model Player {
  id          String    @id @default(uuid())
  tournamentId String   @map("tournament_id") // Link player to specific tournament
  firstName   String
  lastName    String
  email       String?
  gender      Gender?
  dupr        String?   // Changed to String for DUPR ID
  duprRating  Decimal?  @db.Decimal(3, 2) @map("dupr_rating") // New field for DUPR rating
  isPaid      Boolean   @default(false)   @map("is_paid")   // New field for payment status
  isWaitlist  Boolean   @default(false)   @map("is_waitlist")   // New field for waitlist status
  birthDate   DateTime?
  externalId  String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  tournament  Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  teamPlayers TeamPlayer[]

  @@map("players")
}

model TeamPlayer {
  id       String      @id @default(uuid())
  teamId   String
  playerId String
  role     PlayerRole  @default(PLAYER)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  // Relations
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  player Player @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([teamId, playerId])
  @@map("team_players")
}

model RoundRobinGroup {
  id           String   @id @default(uuid())
  tournamentId String
  name         String
  rrSettingsId String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  tournament Tournament         @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  rrSettings RRSettings         @relation(fields: [rrSettingsId], references: [id], onDelete: Cascade)
  bindings    DivisionRRBinding[]
  matches     Match[]
  standings   Standing[]

  @@map("round_robin_groups")
}

model RRSettings {
  id            String      @id @default(uuid())
  targetPoints  Int         @default(11)
  winBy         Int         @default(2)
  gamesPerMatch Int         @default(1)
  bestOfMode    BestOfMode  @default(FIXED_GAMES)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  // Relations
  rrGroups RoundRobinGroup[]

  @@map("rr_settings")
}

model DivisionRRBinding {
  id         String   @id @default(uuid())
  divisionId String
  rrGroupId  String
  status     BindingStatus @default(BOUND)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  division Division        @relation(fields: [divisionId], references: [id], onDelete: Cascade)
  rrGroup  RoundRobinGroup @relation(fields: [rrGroupId], references: [id], onDelete: Cascade)

  @@unique([divisionId, rrGroupId])
  @@map("division_rr_bindings")
}

model Match {
  id            String      @id @default(uuid())
  rrGroupId     String?
  divisionId    String?
  poolId        String?
  roundIndex    Int
  stage         MatchStage
  teamAId       String
  teamBId       String
  bestOfMode    BestOfMode
  gamesCount    Int
  targetPoints  Int
  winBy         Int
  winnerTeamId  String?
  locked        Boolean     @default(false)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  // Relations
  rrGroup  RoundRobinGroup? @relation(fields: [rrGroupId], references: [id], onDelete: Cascade)
  division Division?        @relation(fields: [divisionId], references: [id], onDelete: Cascade)
  pool     Pool?            @relation(fields: [poolId], references: [id], onDelete: Cascade)
  teamA    Team             @relation("TeamA", fields: [teamAId], references: [id], onDelete: Cascade)
  teamB    Team             @relation("TeamB", fields: [teamBId], references: [id], onDelete: Cascade)
  games    Game[]

  @@map("matches")
}

model Game {
  id       String    @id @default(uuid())
  matchId  String
  index    Int
  scoreA   Int       @default(0)
  scoreB   Int       @default(0)
  winner   GameWinner?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)

  @@unique([matchId, index])
  @@map("games")
}

model Standing {
  id            String   @id @default(uuid())
  rrGroupId     String?
  divisionId    String?
  poolId        String?
  teamId        String
  wins          Int      @default(0)
  losses        Int      @default(0)
  pointsFor     Int      @default(0)
  pointsAgainst Int      @default(0)
  pointDiff     Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  rrGroup  RoundRobinGroup? @relation(fields: [rrGroupId], references: [id], onDelete: Cascade)
  division Division?        @relation(fields: [divisionId], references: [id], onDelete: Cascade)
  pool     Pool?            @relation(fields: [poolId], references: [id], onDelete: Cascade)
  team     Team             @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([rrGroupId, teamId])
  @@unique([divisionId, teamId])
  @@unique([poolId, teamId])
  @@map("standings")
}

model ImportJob {
  id           String      @id @default(uuid())
  tournamentId String
  source       ImportSource @default(PBT_CSV)
  status       ImportStatus @default(PENDING)
  mappingJson  Json?
  rawFileUrl   String?
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  // Relations
  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@map("import_jobs")
}

model AuditLog {
  id         String   @id @default(uuid())
  actorUserId String
  tournamentId String
  action     String
  entityType String
  entityId   String
  payload    Json?
  createdAt  DateTime @default(now())

  // Relations
  actor     User       @relation(fields: [actorUserId], references: [id], onDelete: Cascade)
  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@map("audit_logs")
}

// Enums
enum UserRole {
  TD
  ASSISTANT
}

enum TeamKind {
  SINGLES_1v1
  DOUBLES_2v2
  SQUAD_4v4
}

enum PairingMode {
  FIXED
  MIX_AND_MATCH
}

enum GenderConstraint {
  ANY
  MEN
  WOMEN
  MIXED
}

enum Gender {
  M
  F
  X
}

enum PlayerRole {
  CAPTAIN
  PLAYER
  SUB
}

enum BestOfMode {
  FIXED_GAMES
  BEST_OF
}

enum BindingStatus {
  BOUND
  UNBOUND
}

enum MatchStage {
  ROUND_ROBIN
  ELIMINATION
  PLAY_IN
}

enum GameWinner {
  A
  B
}

enum PrizeKind {
  CASH
  OTHER
}

enum ImportSource {
  PBT_CSV
}

enum ImportStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum DivisionStage {
  RR_IN_PROGRESS
  RR_COMPLETE
  PLAY_IN_SCHEDULED
  PLAY_IN_IN_PROGRESS
  PLAY_IN_COMPLETE
  PO_R1_SCHEDULED
  PO_R1_IN_PROGRESS
  PO_R1_COMPLETE
  PO_R2_SCHEDULED
  PO_R2_IN_PROGRESS
  PO_R2_COMPLETE
  PO_R3_SCHEDULED
  PO_R3_IN_PROGRESS
  PO_R3_COMPLETE
  FINAL_SCHEDULED
  FINAL_IN_PROGRESS
  FINAL_COMPLETE
  DIVISION_COMPLETE
}
